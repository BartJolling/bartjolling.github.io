---
layout: post
title:  "Using a custom XmlSerializer to format WCF operation response"
date: 2022-06-19
categories: blog
tags: [WCF, XmlSerializer, SOAP, XML]
modified_time: 2022-06-19
excerpt: "The SOAP XML output generated by WCF can be customized but documentation on how to do it is becoming difficult to find. This article puts together steps from several different sources to explain how to inject a custom XmlSerializer into a WCF Operation in order to customize the response."
cover-img: /assets/img/2022-06-19-custom-xmlserializer-wcf-operation-cover.jpg
thumbnail-img: /assets/img/2022-06-19-custom-xmlserializer-wcf-operation-thumb.jpg
share-img: /assets/img/2022-06-19-custom-xmlserializer-wcf-operation-thumb.jpg
---

The SOAP XML output generated by WCF can be customized but end-to-end documentation decribing how to do it is becoming difficult to find. This article puts together steps from several different sources -most written more than 10 years ago- to explain how to inject a custom XmlSerializer into a WCF Operation in order to customize the response format.

## Starting from the WSDL File

Our team was tasked to build a new SOAP Service to run as a drop-in replacement for an existing one. We were given a `.wsdl` file and a folder full of `.xsd` files to start from.

As we all are C# developers we decided to stick to the available Microsoft tooling. We created a Visual Studio C# project on the .NET Framework 4.8 and generated the `ServiceContract` using `SvcUtil.exe`.

## Custom XmlSerializer

We needed to introduce a custom date/time format but changing the `DataContract` generated by SvcUtil.exe is highly discouraged because the changes will be overwritten when regenerating the files. The contracts however are generated as partial classes, so it is possible to inject custom properties and tell the XmlSerializer to use those.

If a data contract looks like this:

```` csharp
[System.CodeDom.Compiler.GeneratedCodeAttribute("svcutil", "4.8.3928.0")]
[System.SerializableAttribute()]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Xml.Serialization.XmlTypeAttribute(TypeName="Document", Namespace="...")]
public partial class Document
{
    private System.DateTime creationField;    

    [System.Xml.Serialization.XmlElementAttribute()]
    public System.DateTime Creation
    {
        get { return this.creationField; }
        set { this.creationField = value; }
    }
}
````

You can add an additional `string CreationValue` property by creating this partial class:

```` csharp
public partial class Document
{
    private string _creationField;

    [XmlElementAttribute()]
    public string CreationValue
    {
        get { return _creationField; }
        set { _creationField = value; }
    }
}
````

And then configure the XmlSerializer to replace the old property with the new one during deserialization:

```` csharp
public static XmlAttributeOverrides SerializerOverrides()
{
    var ignore = new XmlAttributes() { XmlIgnore = true };

    var creation = new XmlAttributes();
    var creationAttribute = new XmlElementAttribute { ElementName = "Creation" };
    creation.XmlElements.Add(creationAttribute);

    attrOverrides.Add(typeof(Document), "Creation", ignore);
    attrOverrides.Add(typeof(Document), "CreationValue", creation);    
}

_serializer = new XmlSerializer(typeof(GetMessageResponse), SerializerOverrides());
````

## Creating the XmlObjectSerializer

Unfortunately, it is not possible to pass the `XmlAttributesOverrides` to the XmlSerializer that is used by the WCF pipeline. However, we can wrap it in a custom `XmlObjectSerializer` and tell WCF to use that one. [Andrew Arnott](https://github.com/AArnott) describes [how to do this on Microsoft's DevBlog](https://devblogs.microsoft.com/premier-developer/using-the-xmlserializer-as-an-xmlobjectserializer-with-wcf/).

Because of the overrides, we need two `XmlSerializer` instances:
- A first one with `serializer` overrides that use the new `CreationValue` during serialization, allowing for custom formatting of the original field.
- A second one with the inverse `parser` overrides, allowing for reading a custom format but storing it in the original field.

`XmlObjectSerializer` requires implementing some methods. Those just forward to methods on the wrapped `XmlSerializer` instances. The important one here is `WriteObject`. For a full implementation, check out Andrew Arnott's article mentioned above.

```` csharp
public class DocumentSerializer : XmlObjectSerializer
{
    private readonly XmlSerializer _serializer;
    private readonly XmlSerializer _parser;

    public DocumentSerializer()
    {
        _serializer = new XmlSerializer(typeof(GetMessageResponse), SerializerOverrides());
        
        // 'ParserOverrides' left as exercise to the reader
        _parser = new XmlSerializer(typeof(GetMessageResponse), ParserOverrides()); 
    }

    public override void WriteObject(XmlDictionaryWriter writer, object graph)
    {
        if (writer == null)
            throw new ArgumentNullException("writer");

        _serializer.Serialize(writer, graph, namespaces);
    }
}
````

## Injecting the XmlObjectSerializer in the WCF pipeline

Putting the new `DocumentSerializer` in the pipeline of a WCF Operation, requires defining a new DispathMessageFormatter and then applying that formatter by attaching a new OperationBehavior to that WCF Operation, that is responsible for setting this new formatter.

### IDispatchMessageFormatter

WCF exposes the `IDispatchMessageFormatter` for injecting classes that can deserialize request messages and serialize response messages in a WCF service application. This is were we can apply our custom `DocumentSerializer` class. On server side, we only want to be able to customize the `SerializeReply` method. For the `DeserializeRequest`, we just continue using the existing DispatchMessageFormatter.

```` csharp
public class DocumentDispatchFormatter : IDispatchMessageFormatter
{
    private IDispatchMessageFormatter InnerDispatchFormatter { get; set; }
    XmlObjectSerializer Serializer { get; set; }

    public DocumentDispatchFormatter(IDispatchMessageFormatter formatter)
    {
        InnerDispatchFormatter = formatter ?? throw new ArgumentNullException(nameof(formatter));
        Serializer = new DocumentSerializer();
    }

    #region server
    public void DeserializeRequest(Message message, object[] parameters)
    {
        InnerDispatchFormatter.DeserializeRequest(message, parameters);
    }

    public Message SerializeReply(MessageVersion messageVersion, object[] parameters, object result)
    {
        var wrappedResponse = result as DocumentResponse1;
        var response = wrappedResponse.DocumentResponse;

        Message message = Message.CreateMessage(messageVersion, "Document", response, Serializer);
        return message;
    }
    #endregion
}
````

### IOperationBehavior

The final step is to apply the `DocumentDispatchFormatter` to the WCF Operation that requires the custom response format. This can be done by creating an implementation of the `IOperationBehavior` attribute, as shown below.

On server side, we only need to customize the `DispatchBehavior`. We retrieve the inner `XmlSerializerOperationBehavior` formatter behavior, apply the DispatchBehavior and set the `DocumentDispatchFormatter` we defined above as its formatter.

We pass the original inner formatter to the new DocumentDispatcher because we still need it for deserializing the requests.

```` csharp
public class DocumentSerializerAttribute : Attribute, IOperationBehavior
{
    private IOperationBehavior InnerFormatterBehavior { get; set; }

    public void AddBindingParameters(OperationDescription operationDescription, BindingParameterCollection bindingParameters)
    {
        if (InnerFormatterBehavior != null)
        {
            InnerFormatterBehavior.AddBindingParameters(operationDescription, bindingParameters);
        }
    }

    public void ApplyClientBehavior(OperationDescription operationDescription, ClientOperation clientOperation)
    {
        throw new NotImplementedException();
    }

    public void ApplyDispatchBehavior(OperationDescription operationDescription, DispatchOperation dispatchOperation)
    {
        InnerFormatterBehavior = operationDescription.Behaviors.Find<XmlSerializerOperationBehavior>();

        if (InnerFormatterBehavior != null && dispatchOperation.Formatter == null)
        {
            // no formatter has been applied yet
            InnerFormatterBehavior.ApplyDispatchBehavior(operationDescription, dispatchOperation);
        }
        dispatchOperation.Formatter = new DocumentDispatchFormatter(dispatchOperation.Formatter);
    }

    public void Validate(OperationDescription operationDescription)
    {
        if (InnerFormatterBehavior != null)
        {
            InnerFormatterBehavior.Validate(operationDescription);
        }
    }
}
````